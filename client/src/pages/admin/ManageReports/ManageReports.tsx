import { useState, useEffect } from 'react';
import {
  Card,
  Row,
  Col,
  Button,
  Space,
  Select,
  DatePicker,
  Typography,
  Form,
  Input,
  Checkbox,
  message,
  Alert,
  Tag,
  Statistic,
  List,
  Empty,
} from 'antd';
import {
  FileTextOutlined,
  FilePdfOutlined,
  DownloadOutlined,
  PrinterOutlined,
  CheckCircleOutlined,
  BarChartOutlined,
  DatabaseOutlined,
  ExperimentOutlined,
  HistoryOutlined,
} from '@ant-design/icons';
import { AdminLayout } from '../../../components/layouts';
import { api } from '../../../services/api';
import type { Device, SensorReading, ReportType, ReportConfig, ReportHistory } from '../../../schemas';
import dayjs from 'dayjs';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';

const { Title, Text } = Typography;
const { RangePicker } = DatePicker;
const { TextArea } = Input;

const ManageReports = () => {
  const [devices, setDevices] = useState<Device[]>([]);
  const [selectedType, setSelectedType] = useState<ReportType>('water_quality');
  const [loading, setLoading] = useState(false);
  const [generating, setGenerating] = useState(false);
  const [reportHistory, setReportHistory] = useState<ReportHistory[]>([]);
  const [form] = Form.useForm();

  useEffect(() => {
    loadDevices();
    loadReportHistory();
  }, []);

  const loadDevices = async () => {
    setLoading(true);
    try {
      const data = await api.listDevices();
      setDevices(data);
    } catch (error) {
      message.error('Failed to load devices');
      console.error('Error loading devices:', error);
    } finally {
      setLoading(false);
    }
  };

  const loadReportHistory = () => {
    try {
      // Load report history from localStorage
      const history = JSON.parse(localStorage.getItem('reportHistory') || '[]');
      setReportHistory(history.map((item: any) => ({
        ...item,
        generatedAt: new Date(item.generatedAt)
      })));
    } catch (error) {
      console.warn('Failed to load report history:', error);
      setReportHistory([]);
    }
  };

  const generateWaterQualityReportFromBackend = async (config: ReportConfig, reportData: any) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Add header with logo placeholder
    doc.setFillColor(0, 31, 63); // Navy blue
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Water Quality Analysis Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    // Reset text color
    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report Information from backend data
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text('Report Information', 20, yPos);
    yPos += 7;

    doc.setFont('helvetica', 'normal');
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 5;
    
    if (reportData.period) {
      doc.text(
        `Period: ${dayjs(reportData.period.start).format('MMM D, YYYY')} - ${dayjs(reportData.period.end).format('MMM D, YYYY')}`,
        20,
        yPos
      );
      yPos += 5;
    }
    
    doc.text(`Devices Monitored: ${reportData.devices?.length || config.deviceIds.length}`, 20, yPos);
    yPos += 10;

    // Process devices from backend data
    if (reportData.devices && reportData.devices.length > 0) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Device Analysis', 20, yPos);
      yPos += 7;

      for (const deviceReport of reportData.devices) {
        if (yPos > 250) {
          doc.addPage();
          yPos = 20;
        }

        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(`Device: ${deviceReport.deviceName || deviceReport.deviceId}`, 20, yPos);
        yPos += 5;

        if (deviceReport.location) {
          doc.setFont('helvetica', 'normal');
          doc.text(`Location: ${deviceReport.location}`, 20, yPos);
          yPos += 5;
        }

        // Metrics from backend
        if (deviceReport.metrics) {
          const metrics = deviceReport.metrics;
          
          autoTable(doc, {
            startY: yPos,
            head: [['Parameter', 'Average', 'Min/Max', 'Safe Range', 'Status']],
            body: [
              [
                'Turbidity',
                `${metrics.avgTurbidity?.toFixed(2) || 'N/A'} NTU`,
                `${metrics.minTurbidity?.toFixed(2) || 'N/A'} / ${metrics.maxTurbidity?.toFixed(2) || 'N/A'}`,
                '0 - 5 NTU',
                (metrics.avgTurbidity || 0) <= 5 ? 'GOOD' : 'WARNING'
              ],
              [
                'TDS',
                `${metrics.avgTDS?.toFixed(2) || 'N/A'} ppm`,
                `${metrics.minTDS?.toFixed(2) || 'N/A'} / ${metrics.maxTDS?.toFixed(2) || 'N/A'}`,
                '0 - 500 ppm',
                (metrics.avgTDS || 0) <= 500 ? 'GOOD' : 'WARNING'
              ],
              [
                'pH Level',
                metrics.avgPH?.toFixed(2) || 'N/A',
                `${metrics.minPH?.toFixed(2) || 'N/A'} / ${metrics.maxPH?.toFixed(2) || 'N/A'}`,
                '6.5 - 8.5',
                ((metrics.avgPH || 0) >= 6.5 && (metrics.avgPH || 0) <= 8.5) ? 'GOOD' : 'WARNING'
              ],
            ],
            styles: { fontSize: 7, cellPadding: 2 },
            headStyles: { fillColor: [0, 31, 63], textColor: [255, 255, 255] },
            alternateRowStyles: { fillColor: [245, 245, 245] },
            columnStyles: {
              4: { 
                cellWidth: 20,
                fontStyle: 'bold',
              }
            },
            didParseCell: function(data: any) {
              if (data.column.index === 4) {
                const status = data.cell.raw;
                if (status === 'GOOD') {
                  data.cell.styles.textColor = [82, 196, 26];
                } else {
                  data.cell.styles.textColor = [250, 173, 20];
                }
              }
            },
          });

          yPos = (doc as any).lastAutoTable.finalY + 10;
        }

        // Alerts from backend
        if (deviceReport.alerts && deviceReport.alerts.length > 0) {
          doc.setFontSize(9);
          doc.setFont('helvetica', 'bold');
          doc.text('Alerts:', 20, yPos);
          yPos += 5;

          deviceReport.alerts.forEach((alert: any) => {
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            const alertColor: [number, number, number] = alert.severity === 'high' ? [255, 77, 79] : [250, 173, 20];
            doc.setTextColor(...alertColor);
            doc.text(`â€¢ ${alert.message}`, 25, yPos);
            doc.setTextColor(0, 0, 0);
            yPos += 4;
          });
          yPos += 5;
        }
      }
    }

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
      doc.text(
        `Generated by IoT Water Quality Monitoring System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const generateDeviceStatusReportFromBackend = async (config: ReportConfig, reportData: any) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Header
    doc.setFillColor(0, 31, 63);
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Device Status Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report Info
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 10;

    // Backend summary data
    if (reportData.summary) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('System Overview', 20, yPos);
      yPos += 7;

      const summary = reportData.summary;
      doc.setFontSize(9);
      doc.setFont('helvetica', 'normal');
      doc.text(`Total Devices: ${summary.totalDevices}`, 20, yPos);
      yPos += 5;
      doc.text(`Health Score: ${summary.healthScore}%`, 20, yPos);
      yPos += 10;

      if (summary.statusBreakdown) {
        autoTable(doc, {
          startY: yPos,
          head: [['Status', 'Count', 'Percentage']],
          body: [
            ['Online', summary.statusBreakdown.online?.toString() || '0', `${summary.statusBreakdown.online || 0}%`],
            ['Offline', summary.statusBreakdown.offline?.toString() || '0', `${summary.statusBreakdown.offline || 0}%`],
            ['Error', summary.statusBreakdown.error?.toString() || '0', `${summary.statusBreakdown.error || 0}%`],
            ['Maintenance', summary.statusBreakdown.maintenance?.toString() || '0', `${summary.statusBreakdown.maintenance || 0}%`],
          ],
          styles: { fontSize: 9, cellPadding: 3 },
          headStyles: { fillColor: [0, 31, 63] },
          alternateRowStyles: { fillColor: [245, 245, 245] },
        });

        yPos = (doc as any).lastAutoTable.finalY + 10;
      }
    }

    // Device details from backend
    if (reportData.devices) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Device Details', 20, yPos);
      yPos += 7;

      const deviceData = reportData.devices.map((device: any) => [
        device.deviceId,
        device.name || 'N/A',
        device.type || 'N/A',
        device.status?.toUpperCase() || 'UNKNOWN',
        device.firmwareVersion || 'N/A',
        device.lastSeen ? dayjs(device.lastSeen).format('MMM D, YYYY HH:mm') : 'N/A',
      ]);

      autoTable(doc, {
        startY: yPos,
        head: [['Device ID', 'Name', 'Type', 'Status', 'Firmware', 'Last Seen']],
        body: deviceData,
        styles: { fontSize: 8, cellPadding: 2 },
        headStyles: { fillColor: [0, 31, 63] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
        columnStyles: {
          3: { fontStyle: 'bold' }
        },
        didParseCell: function(data: any) {
          if (data.column.index === 3) {
            const status = data.cell.raw.toLowerCase();
            if (status === 'online') {
              data.cell.styles.textColor = [82, 196, 26];
            } else if (status === 'offline') {
              data.cell.styles.textColor = [128, 128, 128];
            } else {
              data.cell.styles.textColor = [255, 77, 79];
            }
          }
        },
      });
    }

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
      doc.text(
        `IoT Device Management System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const generateDataSummaryReportFromBackend = async (config: ReportConfig, reportData: any) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Header
    doc.setFillColor(0, 31, 63);
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Data Summary Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report metadata
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 10;

    // Summary statistics from backend
    if (reportData.summary) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Data Summary', 20, yPos);
      yPos += 7;

      const summary = reportData.summary;
      autoTable(doc, {
        startY: yPos,
        head: [['Metric', 'Value']],
        body: [
          ['Total Readings', summary.totalReadings?.toString() || 'N/A'],
          ['Total Devices', summary.totalDevices?.toString() || 'N/A'],
          ['Data Completeness', summary.dataCompleteness || 'N/A'],
        ],
        styles: { fontSize: 9, cellPadding: 3 },
        headStyles: { fillColor: [0, 31, 63] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
      });

      yPos = (doc as any).lastAutoTable.finalY + 10;
    }

    // Statistical analysis from backend
    if (reportData.statistics) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Statistical Analysis', 20, yPos);
      yPos += 7;

      const stats = reportData.statistics;
      const statsData = [];

      if (stats.turbidity) {
        statsData.push(['Turbidity', 'Mean', stats.turbidity.mean?.toFixed(2) || 'N/A', 'NTU']);
        statsData.push(['', 'Std Dev', stats.turbidity.stdDev?.toFixed(2) || 'N/A', 'NTU']);
        statsData.push(['', 'Min/Max', `${stats.turbidity.min?.toFixed(2) || 'N/A'} / ${stats.turbidity.max?.toFixed(2) || 'N/A'}`, 'NTU']);
      }

      if (stats.tds) {
        statsData.push(['TDS', 'Mean', stats.tds.mean?.toFixed(2) || 'N/A', 'ppm']);
        statsData.push(['', 'Std Dev', stats.tds.stdDev?.toFixed(2) || 'N/A', 'ppm']);
        statsData.push(['', 'Min/Max', `${stats.tds.min?.toFixed(2) || 'N/A'} / ${stats.tds.max?.toFixed(2) || 'N/A'}`, 'ppm']);
      }

      if (stats.ph) {
        statsData.push(['pH', 'Mean', stats.ph.mean?.toFixed(2) || 'N/A', '']);
        statsData.push(['', 'Std Dev', stats.ph.stdDev?.toFixed(2) || 'N/A', '']);
        statsData.push(['', 'Min/Max', `${stats.ph.min?.toFixed(2) || 'N/A'} / ${stats.ph.max?.toFixed(2) || 'N/A'}`, '']);
      }

      if (statsData.length > 0) {
        autoTable(doc, {
          startY: yPos,
          head: [['Parameter', 'Statistic', 'Value', 'Unit']],
          body: statsData,
          styles: { fontSize: 8, cellPadding: 2 },
          headStyles: { fillColor: [0, 31, 63] },
          alternateRowStyles: { fillColor: [245, 245, 245] },
        });
      }
    }

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
      doc.text(
        `IoT Data Analysis System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const generateComplianceReportFromBackend = async (config: ReportConfig, reportData: any) => {
    const doc = new jsPDF();
    let yPos = 20;

    // Header
    doc.setFillColor(0, 31, 63);
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(24);
    doc.setFont('helvetica', 'bold');
    doc.text('Compliance Report', 105, 20, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(config.title, 105, 30, { align: 'center' });

    doc.setTextColor(0, 0, 0);
    yPos = 50;

    // Report metadata
    doc.setFontSize(9);
    doc.text(`Generated: ${dayjs().format('MMMM D, YYYY [at] h:mm A')}`, 20, yPos);
    yPos += 5;
    doc.text(`Generated By: ${config.generatedBy}`, 20, yPos);
    yPos += 10;

    // Standards reference from backend
    if (reportData.standards) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Regulatory Standards', 20, yPos);
      yPos += 7;

      const standards = reportData.standards;
      doc.setFontSize(8);
      doc.setFont('helvetica', 'normal');
      doc.text(`Turbidity: ${standards.turbidity || 'N/A'}`, 20, yPos);
      yPos += 4;
      doc.text(`TDS: ${standards.tds || 'N/A'}`, 20, yPos);
      yPos += 4;
      doc.text(`pH: ${standards.ph || 'N/A'}`, 20, yPos);
      yPos += 4;
      doc.text(`Reference: ${standards.reference || 'WHO/EPA Standards'}`, 20, yPos);
      yPos += 10;
    }

    // Compliance summary from backend
    if (reportData.summary) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Compliance Summary', 20, yPos);
      yPos += 7;

      const summary = reportData.summary;
      autoTable(doc, {
        startY: yPos,
        head: [['Metric', 'Value']],
        body: [
          ['Total Devices', summary.totalDevices?.toString() || 'N/A'],
          ['Compliant Devices', summary.compliantDevices?.toString() || 'N/A'],
          ['Compliance Rate', summary.complianceRate || 'N/A'],
        ],
        styles: { fontSize: 9, cellPadding: 3 },
        headStyles: { fillColor: [0, 31, 63] },
        alternateRowStyles: { fillColor: [245, 245, 245] },
      });

      yPos = (doc as any).lastAutoTable.finalY + 10;
    }

    // Device compliance details from backend
    if (reportData.devices && reportData.devices.length > 0) {
      doc.setFontSize(10);
      doc.setFont('helvetica', 'bold');
      doc.text('Device Compliance Details', 20, yPos);
      yPos += 7;

      for (const deviceCompliance of reportData.devices) {
        if (yPos > 240) {
          doc.addPage();
          yPos = 20;
        }

        doc.setFontSize(9);
        doc.setFont('helvetica', 'bold');
        doc.text(`Device: ${deviceCompliance.deviceName || deviceCompliance.deviceId}`, 20, yPos);
        yPos += 5;

        if (deviceCompliance.complianceStatus) {
          const complianceData = deviceCompliance.complianceStatus.map((status: any) => [
            status.parameter || 'N/A',
            status.value?.toFixed(2) || 'N/A',
            status.standard?.toString() || 'N/A',
            status.status?.toUpperCase() || 'UNKNOWN',
            `${status.percentage?.toFixed(1) || '0'}%`
          ]);

          autoTable(doc, {
            startY: yPos,
            head: [['Parameter', 'Value', 'Standard', 'Status', 'Compliance %']],
            body: complianceData,
            styles: { fontSize: 7, cellPadding: 2 },
            headStyles: { fillColor: [0, 31, 63] },
            alternateRowStyles: { fillColor: [245, 245, 245] },
            columnStyles: {
              3: { fontStyle: 'bold' }
            },
            didParseCell: function(data: any) {
              if (data.column.index === 3) {
                const status = data.cell.raw.toLowerCase();
                if (status === 'compliant') {
                  data.cell.styles.textColor = [82, 196, 26];
                } else {
                  data.cell.styles.textColor = [255, 77, 79];
                }
              }
            },
          });

          yPos = (doc as any).lastAutoTable.finalY + 8;
        }
      }
    }

    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(128, 128, 128);
      doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
      doc.text(
        `IoT Compliance Monitoring System - ${dayjs().format('YYYY')}`,
        105,
        290,
        { align: 'center' }
      );
    }

    return doc;
  };

  const handleGenerateReport = async (values: any) => {
    setGenerating(true);
    
    try {
      const config: ReportConfig = {
        type: selectedType,
        title: values.title || 'System Report',
        deviceIds: values.devices || [],
        dateRange: values.dateRange || null,
        includeCharts: values.includeCharts || false,
        includeRawData: values.includeRawData || true,
        includeStatistics: values.includeStatistics || true,
        notes: values.notes || '',
        generatedBy: 'Admin User',
      };

      if (config.deviceIds.length === 0) {
        message.warning('Please select at least one device');
        setGenerating(false);
        return;
      }

      // Convert date range to timestamps for API
      let startDate: number | undefined;
      let endDate: number | undefined;
      
      if (config.dateRange) {
        startDate = config.dateRange[0].valueOf();
        endDate = config.dateRange[1].valueOf();
      }

      // Generate report data from backend
      let reportData: any;
      let allSensorData: SensorReading[] = [];

      try {
        // Fetch backend report data based on type
        switch (selectedType) {
          case 'water_quality':
            if (config.deviceIds.length === 1) {
              // Single device report
              reportData = await api.reports.generateWaterQualityReport(
                config.deviceIds[0],
                startDate,
                endDate,
                config.includeCharts
              );
            } else {
              // Multi-device report - fetch each device separately and combine
              const reports = await Promise.all(
                config.deviceIds.map(deviceId =>
                  api.reports.generateWaterQualityReport(deviceId, startDate, endDate, false)
                )
              );
              reportData = {
                title: 'Multi-Device Water Quality Analysis Report',
                period: { start: startDate || Date.now() - 7 * 24 * 60 * 60 * 1000, end: endDate || Date.now() },
                devices: reports.flatMap(report => report.devices || [])
              };
            }
            
            // Extract sensor data for PDF generation
            if (reportData.devices) {
              allSensorData = reportData.devices.flatMap((device: any) => device.readings || []);
            }
            break;

          case 'device_status':
            reportData = await api.reports.generateDeviceStatusReport();
            break;

          case 'data_summary':
            if (config.deviceIds.length === 1) {
              reportData = await api.reports.generateDataSummaryReport(
                config.deviceIds[0],
                startDate,
                endDate
              );
            } else {
              // Multi-device data summary - use no specific device ID
              reportData = await api.reports.generateDataSummaryReport(
                undefined,
                startDate,
                endDate
              );
            }
            break;

          case 'compliance':
            if (config.deviceIds.length === 1) {
              reportData = await api.reports.generateComplianceReport(
                config.deviceIds[0],
                startDate,
                endDate
              );
            } else {
              // Multi-device compliance - use no specific device ID
              reportData = await api.reports.generateComplianceReport(
                undefined,
                startDate,
                endDate
              );
            }
            break;

          default:
            throw new Error(`Unsupported report type: ${selectedType}`);
        }

        console.log('Backend report data:', reportData);

      } catch (apiError) {
        console.warn('Backend API failed, falling back to local sensor data:', apiError);
        message.warning('Using local data - backend report service unavailable');
        
        // Fallback: Load sensor data directly for basic report generation
        for (const deviceId of config.deviceIds) {
          try {
            const data = await api.getSensorHistory(deviceId, 100);
            allSensorData.push(...data);
          } catch (sensorError) {
            console.warn(`Failed to fetch sensor data for device ${deviceId}:`, sensorError);
          }
        }

        // Filter by date range if specified
        if (config.dateRange) {
          allSensorData = allSensorData.filter(
            d => d.timestamp >= startDate! && d.timestamp <= endDate!
          );
        }

        // Create minimal report data structure
        reportData = {
          title: config.title,
          period: { start: startDate, end: endDate },
          devices: config.deviceIds.map(deviceId => ({
            deviceId,
            readings: allSensorData.filter(d => d.deviceId === deviceId)
          }))
        };
      }

      let doc: jsPDF;

      // Generate PDF using backend data + local formatting
      switch (selectedType) {
        case 'water_quality':
          doc = await generateWaterQualityReportFromBackend(config, reportData);
          break;
        case 'device_status':
          doc = await generateDeviceStatusReportFromBackend(config, reportData);
          break;
        case 'data_summary':
          doc = await generateDataSummaryReportFromBackend(config, reportData);
          break;
        case 'compliance':
          doc = await generateComplianceReportFromBackend(config, reportData);
          break;
        default:
          doc = await generateWaterQualityReportFromBackend(config, reportData);
      }

      // Save PDF
      const filename = `${config.type}-report-${dayjs().format('YYYY-MM-DD-HHmmss')}.pdf`;
      doc.save(filename);

      // Add to history
      const newReport: ReportHistory = {
        id: Date.now().toString(),
        type: config.title,
        title: config.title,
        generatedAt: new Date(),
        devices: config.deviceIds.length,
        pages: doc.getNumberOfPages(),
      };
      
      // Store in localStorage for persistence
      const existingHistory = JSON.parse(localStorage.getItem('reportHistory') || '[]');
      const updatedHistory = [newReport, ...existingHistory].slice(0, 10); // Keep last 10 reports
      localStorage.setItem('reportHistory', JSON.stringify(updatedHistory));
      setReportHistory(updatedHistory);

      message.success('Report generated successfully!');
    } catch (error) {
      console.error('Error generating report:', error);
      message.error(`Failed to generate report: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setGenerating(false);
    }
  };

  const reportTypes = [
    {
      key: 'water_quality',
      title: 'Water Quality Report',
      description: 'Comprehensive analysis of water quality parameters including turbidity, TDS, and pH levels',
      icon: <ExperimentOutlined />,
      color: '#1890ff',
    },
    {
      key: 'device_status',
      title: 'Device Status Report',
      description: 'Overview of all device statuses, connectivity, and operational health',
      icon: <DatabaseOutlined />,
      color: '#52c41a',
    },
    {
      key: 'data_summary',
      title: 'Data Summary Report',
      description: 'Statistical summary of sensor data over selected time period',
      icon: <BarChartOutlined />,
      color: '#722ed1',
    },
    {
      key: 'compliance',
      title: 'Compliance Report',
      description: 'Regulatory compliance assessment and quality standards verification',
      icon: <CheckCircleOutlined />,
      color: '#faad14',
    },
  ];

  return (
    <AdminLayout>
      <div style={{ padding: '24px' }}>
        {/* Header */}
        <Row justify="space-between" align="middle" style={{ marginBottom: 24 }}>
          <Col>
            <Title level={2}>
              <FileTextOutlined /> Report Management
            </Title>
            <Text type="secondary">
              Generate professional PDF reports for water quality analysis and device monitoring
            </Text>
          </Col>
        </Row>

        {/* Report Type Selection */}
        <Card title="Select Report Type" style={{ marginBottom: 24 }}>
          <Row gutter={[16, 16]}>
            {reportTypes.map(type => (
              <Col xs={24} sm={12} lg={6} key={type.key}>
                <Card
                  hoverable
                  onClick={() => setSelectedType(type.key as ReportType)}
                  style={{
                    borderColor: selectedType === type.key ? type.color : undefined,
                    borderWidth: selectedType === type.key ? 2 : 1,
                  }}
                >
                  <Space direction="vertical" style={{ width: '100%' }} align="center">
                    <div style={{ fontSize: 32, color: type.color }}>
                      {type.icon}
                    </div>
                    <Text strong>{type.title}</Text>
                    <Text type="secondary" style={{ fontSize: 12, textAlign: 'center' }}>
                      {type.description}
                    </Text>
                    {selectedType === type.key && (
                      <Tag color={type.color}>Selected</Tag>
                    )}
                  </Space>
                </Card>
              </Col>
            ))}
          </Row>
        </Card>

        {/* Report Configuration */}
        <Row gutter={16}>
          <Col xs={24} lg={16}>
            <Card
              title={
                <Space>
                  <FilePdfOutlined />
                  <span>Report Configuration</span>
                </Space>
              }
            >
              <Form
                form={form}
                layout="vertical"
                onFinish={handleGenerateReport}
                initialValues={{
                  includeStatistics: true,
                  includeRawData: true,
                  includeCharts: false,
                }}
              >
                <Form.Item
                  label="Report Title"
                  name="title"
                  rules={[{ required: true, message: 'Please enter report title' }]}
                >
                  <Input placeholder="e.g., Monthly Water Quality Report" />
                </Form.Item>

                <Form.Item
                  label="Select Devices"
                  name="devices"
                  rules={[{ required: true, message: 'Please select at least one device' }]}
                >
                  <Select
                    mode="multiple"
                    placeholder="Select devices to include"
                    loading={loading}
                    showSearch
                    filterOption={(input, option) =>
                      (option?.label ?? '').toLowerCase().includes(input.toLowerCase())
                    }
                    options={devices.map(device => ({
                      value: device.deviceId,
                      label: `${device.name} (${device.deviceId})`,
                    }))}
                  />
                </Form.Item>

                <Form.Item label="Date Range" name="dateRange">
                  <RangePicker
                    style={{ width: '100%' }}
                    format="YYYY-MM-DD"
                    presets={[
                      { label: 'Last 7 Days', value: [dayjs().subtract(7, 'd'), dayjs()] },
                      { label: 'Last 30 Days', value: [dayjs().subtract(30, 'd'), dayjs()] },
                      { label: 'Last 90 Days', value: [dayjs().subtract(90, 'd'), dayjs()] },
                      { label: 'This Year', value: [dayjs().startOf('year'), dayjs()] },
                    ]}
                  />
                </Form.Item>

                <Form.Item label="Report Options">
                  <Space direction="vertical">
                    <Form.Item name="includeStatistics" valuePropName="checked" noStyle>
                      <Checkbox>Include Statistical Summary</Checkbox>
                    </Form.Item>
                    <Form.Item name="includeRawData" valuePropName="checked" noStyle>
                      <Checkbox>Include Detailed Data Tables</Checkbox>
                    </Form.Item>
                    <Form.Item name="includeCharts" valuePropName="checked" noStyle>
                      <Checkbox disabled>Include Charts & Graphs (Coming Soon)</Checkbox>
                    </Form.Item>
                  </Space>
                </Form.Item>

                <Form.Item label="Additional Notes" name="notes">
                  <TextArea
                    rows={4}
                    placeholder="Add any additional notes or observations to include in the report..."
                  />
                </Form.Item>

                <Form.Item>
                  <Space>
                    <Button
                      type="primary"
                      htmlType="submit"
                      icon={<DownloadOutlined />}
                      loading={generating}
                      size="large"
                    >
                      Generate PDF Report
                    </Button>
                    <Button icon={<PrinterOutlined />} disabled>
                      Print Preview
                    </Button>
                  </Space>
                </Form.Item>
              </Form>
            </Card>
          </Col>

          {/* Report Preview & History */}
          <Col xs={24} lg={8}>
            <Space direction="vertical" style={{ width: '100%' }} size="large">
              {/* Quick Stats */}
              <Card>
                <Statistic
                  title="Reports Generated"
                  value={reportHistory.length}
                  prefix={<FileTextOutlined />}
                  valueStyle={{ color: '#001f3f' }}
                />
              </Card>

              {/* Report History */}
              <Card
                title={
                  <Space>
                    <HistoryOutlined />
                    <span>Recent Reports</span>
                  </Space>
                }
              >
                {reportHistory.length === 0 ? (
                  <Empty
                    description="No reports generated yet"
                    image={Empty.PRESENTED_IMAGE_SIMPLE}
                  />
                ) : (
                  <List
                    dataSource={reportHistory}
                    renderItem={item => (
                      <List.Item>
                        <List.Item.Meta
                          avatar={<FilePdfOutlined style={{ fontSize: 24, color: '#ff4d4f' }} />}
                          title={item.title}
                          description={
                            <Space direction="vertical" size={0}>
                              <Text type="secondary" style={{ fontSize: 12 }}>
                                {dayjs(item.generatedAt).format('MMM D, YYYY h:mm A')}
                              </Text>
                              <Space size={4}>
                                <Tag color="blue">{item.devices} devices</Tag>
                                <Tag color="green">{item.pages} pages</Tag>
                              </Space>
                            </Space>
                          }
                        />
                      </List.Item>
                    )}
                  />
                )}
              </Card>

              {/* Help Card */}
              <Alert
                message="Report Generation Tips"
                description={
                  <ul style={{ margin: 0, paddingLeft: 20 }}>
                    <li>Select relevant devices for focused reports</li>
                    <li>Use date ranges for specific time periods</li>
                    <li>Include statistics for executive summaries</li>
                    <li>Add notes for context and observations</li>
                  </ul>
                }
                type="info"
                showIcon
              />
            </Space>
          </Col>
        </Row>
      </div>
    </AdminLayout>
  );
};

export default ManageReports;
